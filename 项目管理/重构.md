<!--refactor-->

《重构 第2版》读书笔记。

<!--more-->

# 重构基础

## 十六字心法

- 旧的不变
- 新的创建
- 一步切换
- 旧的再见

## 重构的概念

- 如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序
- 重构前，先检查自己是否有一套可靠的测试集，这些测试必须由自我检验能力
- 重构技术就是以微笑的步伐修改程序，如果犯下错误，很容易便可以发现它
- 好代码的检验标准就是人们是否能轻而易举的修改它

## 何时重构

- 添加新功能之前，重构让添加新功能更容易
- 使得代码更容易懂
- 肮脏的代码必须重构，但漂亮的代码也需要很多重构
- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值

## 代码的坏味道

- 神秘命名
    - 如果你想不出一个好名字，背后很可能潜藏着更深的设计问题
- 重复代码
    - 重复代码只是相似而不完全相同，首先尝试重组代码循序，把相似的部分放一起提炼
    - 重复代码位于同一个超类的不同子类中，使用函数上移避免两个字类相互调用
- 过长函数
    - 活得最长，最好的程序，函数都比较短

# 重构实践

## 以明确的函数代替参数

- 函数中的标记参数隐藏了函数调用中存在的差异性
- 移除标记参数不仅使代码更整洁，并且能够帮助开发工具更好地发挥作用

## 以查询取代临时变量

- 在类中使用 getter 查询某些计算值
- 不需要再将变量作为参数传递给提炼出来的小函数

## 内联函数

- 有时候语句块本来就清晰明了，就没有必要再提炼一个单独的函数

## 内联变量

- 如果变量不比表达式本身更具有表达力，应该使用内联的方式消除这个变量

## 函数分离

- 任何有返回值的函数，都不应该有看得到的副作用
- 如果遇到一个既有返回值又有副作用的函数，尝试将查询动作从修改动作中分离出来

## 函数组合成类

- 如果一组函数操作同一块数据（通常将这块数据作为参数传递），这时候考虑组建一个类

## 分解条件表达式

- 使用函数调用作为条件，更能清楚说明进入条件分支的原因

## 处理继承关系

- 公用函数上移到父类
- 公用字段上移到父类
- 构造函数内公用字段上移到父类，通过 super 赋值
- 特有函数下移到子类
- 特有字段下移到子类
- 以 new 不同的子类取代类型码

## 封装变量

- 如果一个数据被广泛使用，最好的做法往往是先以函数的形式封装所有对该数据的访问
- 如果一个类达到需要自封装，考虑把这个类拆小

```js
let defaultOwnerDate = { firstName: 'martin', lastName: 'fowler' };
export function defaultOwner() { return defaultOwnerDate; }
export function setDefaultOwner(arg) { defaultOwnerDate = arg; }
```

## 引入参数对象

- 有一些数据总是结伴同行出没于一个个函数，让这组数据组成一个参数对象更好

## 提炼函数

- 阅读一段代码，理解其作用，以这段代码的用途为函数命名
- 如果你需要花时间浏览一段代码才能弄清楚它到底在干什么，就应该提炼到一个函数中
- 以函数“做什么”来命名，而不是它“怎么做”命名
- 只要提炼的过程中学到了东西，我的时间就没有白费
- 若提炼函数出现作用域变量，则以参数形式传递
- 局部变量过多就不适合使用提炼函数进行重构

## 提炼变量

- 表达式有可能非常复杂难以阅读，使用解释性变量能更好的管理
- 在类中提炼变量可以使用 getter 方法

## 提炼类

- 当一个类维护大量的函数和数据，往往不容易被理解
- 把一类功能成团的方法组成一个新的子类更好维护

## 改变函数声明

- 改进函数名字：先写一句注释描述这个函数的用途，再把这句注释变成函数的名字
- 函数参数尽量松耦合，不跟整个对象进行耦合

## 用管道代替循环

- 用 filter、map 集合管道代替循环，提升代码可读性

```js
// bad
const names = [];
for (const i of input) {
  if (i.job === 'programmer') {
    names.push(i.name);
  }
}

// good
const names = input
  .filter(i => i.job === 'programmer')
  .map(i => i.name);
```

## 移动语句

- 元素的声明点和使用点相互靠近，方便代码理解
- 将关联的代码集中到一块，方便做函数提炼
