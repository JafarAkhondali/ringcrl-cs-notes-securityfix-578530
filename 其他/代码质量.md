<!--Eliminate-Low-Quality-Codes-->

- 消灭低水平竞争
- 鼓励高水平竞争

<!--more-->

# 函数命名

## 用名字表达代码含义

### 有表达力的单词

| 单词  | 可替代单词                                         |
| :---: | -------------------------------------------------- |
| send  | deliver、dispatch、announce、distribute、route     |
| find  | search、extract、locate、recover                   |
| start | launch、create、begin、open                        |
| make  | create、set up、build、generate、compose、add、new |

### for 循环用词

- 使用 i、j、k 作为循环迭代器的名字过于简单
- user_i、member_i 这种名字会更有表达力

### 规范用词

- 布尔相关的命名加上 is、can、should、has 等前缀
- 用 min、max 表示数量范围
- 用 first、last 表示访问空间的包含范围
- begin、end 表示访问空间的排除范围，即 end 不包含尾部

### 注意一致性

#### 介词一致性

如果你使用了 before + after，那么就在代码的所有地方都坚持使用
如果你使用了 before + 完成时，那么就坚持使用

#### 顺序一致性

比如 updateContainerWidth 和 updateHeightOfContainer 的顺序就令人很别扭，同样会引发不可预测

#### 表里一致性

函数名必须完美体现函数的功能，既不能多也不能少。

```js
function getSongs(){
  return $.get('/songs).then((response){
    div.innerText = response.songs
  })
}
```

就违背了表里一致性，getSongs 表示获取歌曲，并没有暗示这个函数会更新页面，但是实际上函数更新了 div，这就是表里不一，正确的写法是

```js
// 要么纠正函数名
function getSongsAndUpdateDiv(){
  return $.get('/songs).then((response){
    div.innerText = response.songs
  })
}
```

```js
// 要么写成两个函数
function getSongs(){
  return $.get('/songs)
}
function updateDiv(songs){
  div.innerText = response.songs
}
getSongs().then((response)=>{
  updateDiv(response.songs)
})
```

#### 时间一致性

有可能随着代码的变迁，一个变量的含义已经不同于它一开始的含义了，这个时候你需要及时改掉这个变量的名字。
这一条是最难做到的，因为写代码容易，改代码难。如果这个代码组织得不好，很可能会出现牵一发而动全身的情况（如全局变量就很难改）

## 例子

### 文件夹命名

- 常用项目命名
    - omi、element、master、project、test、vue、iview
- 二级目录
    - build、static、config、src、examples、base、common、issues、assert
- 三级目录
    - libs、models、plugins、skins、images、css、js
- 名词加动词
    - color-pick、button-groups、date-picker、option-grounp、jquery-select、jquery-swiper
- 连接线
    - node_models、async-demo、array-union、array-differ、babel-each

### 文件命名

- 常用组件命名
    - index、message、menu、slider（滑块）、page、progress（进度条）、tooltip（提示）、tree、upload、time、button、checkbox、dialog、cascader（三级联动）
- 常用文件命名
    - index、shopping（购物）、 share（分享）、integral（积分）、advertisement（广告）、pay（支付）、community（社区）、game、docs、bussiness
- 名词加动词
    - share-to-friends，share-to-community，weex-pay，alipay-pay，user-integral，game-page，docs-page

### html 布局命名

- 外套 wrap
    - container
- 头部 header
    - head、header、nav、sub-nav、menu、sub-menu、branding
- 主要内容 main
    - bussiness-title 、bussiness-logo、bussiness-search、bussiness-search-results
- 左侧 main-left
    - side-bar、side-bar-a、side-bar-b
- 内容 content
    - radio-click、radio-heightlight、radio-active、input-seach-off、input-search-on
- 底部 footer
    - service、regsiter、partner、joinus、site-info

### js 变量命名

- 基础类型和引用数据类型
    - 字符串 s_count
    - 布尔类型 b_status
    - 数字类型 n_total

- 引用数据类型
    - 数组 arr_bar
    - 对象 o_bar
    - 函数 f_submit

- 函数动词 + 名词
    - login、logout、expandList、getTotal、keySearch、submitForm、cancel、goMore、searchAll、searchCurrent、clearContent、uploadImage、searchResult

### css 命名

- 公共的 common.css
- 动画 animation.css
- 皮肤 skin.css
- 文字 font.css
- 主题 themes.css
- 打印样式 print.css
- 颜色 color.css


# 干净的代码

## Object.assign 设置默认对象

```js
const menuConfig = {
  title: 'Order',
  // User did not include 'body' key
  buttonText: 'Send',
  cancellable: true
};

function createMenu(config) {
  config = Object.assign({
    title: 'Foo',
    body: 'Bar',
    buttonText: 'Baz',
    cancellable: true
  }, config);

  // config now equals: {title: "Order", body: "Bar", buttonText: "Send", cancellable: true}
  // ...
}

createMenu(menuConfig);
```

## 使用解释变量

```js
const address = 'One Infinite Loop, Cupertino 95014';
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
const [, city, zipCode] = address.match(cityZipCodeRegex) || [];
saveCityZipCode(city, zipCode);
```

## 2 个或更少的函数参数

```js
function createMenu({ title, body, buttonText, cancellable }) {
  // ...
}

createMenu({
  title: 'Foo',
  body: 'Bar',
  buttonText: 'Baz',
  cancellable: true
});
```

## 函数参数不使用 flag

```js
// Bad
function createFile(name, temp) {
  if (temp) {
    fs.create(`./temp/${name}`);
  } else {
    fs.create(name);
  }
}

// Good
function createFile(name) {
  fs.create(name);
}
function createTempFile(name) {
  createFile(`./temp/${name}`);
}
```

# 重构

## 重构基础

### 十六字心法

- 旧的不变
- 新的创建
- 一步切换
- 旧的再见

### 重构的概念

- 如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序
- 重构前，先检查自己是否有一套可靠的测试集，这些测试必须由自我检验能力
- 重构技术就是以微笑的步伐修改程序，如果犯下错误，很容易便可以发现它
- 好代码的检验标准就是人们是否能轻而易举的修改它

### 何时重构

- 添加新功能之前，重构让添加新功能更容易
- 使得代码更容易懂
- 肮脏的代码必须重构，但漂亮的代码也需要很多重构
- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值

### 代码的坏味道

- 神秘命名
    - 如果你想不出一个好名字，背后很可能潜藏着更深的设计问题
- 重复代码
    - 重复代码只是相似而不完全相同，首先尝试重组代码循序，把相似的部分放一起提炼
    - 重复代码位于同一个超类的不同子类中，使用函数上移避免两个字类相互调用
- 过长函数
    - 活得最长，最好的程序，函数都比较短

## 重构实践

### 以明确的函数代替参数

- 函数中的标记参数隐藏了函数调用中存在的差异性
- 移除标记参数不仅使代码更整洁，并且能够帮助开发工具更好地发挥作用

### 以查询取代临时变量

- 在类中使用 getter 查询某些计算值
- 不需要再将变量作为参数传递给提炼出来的小函数

### 内联函数

- 有时候语句块本来就清晰明了，就没有必要再提炼一个单独的函数

### 内联变量

- 如果变量不比表达式本身更具有表达力，应该使用内联的方式消除这个变量

### 函数分离

- 任何有返回值的函数，都不应该有看得到的副作用
- 如果遇到一个既有返回值又有副作用的函数，尝试将查询动作从修改动作中分离出来

### 函数组合成类

- 如果一组函数操作同一块数据（通常将这块数据作为参数传递），这时候考虑组建一个类

### 分解条件表达式

- 使用函数调用作为条件，更能清楚说明进入条件分支的原因

### 处理继承关系

- 公用函数上移到父类
- 公用字段上移到父类
- 构造函数内公用字段上移到父类，通过 super 赋值
- 特有函数下移到子类
- 特有字段下移到子类
- 以 new 不同的子类取代类型码

### 封装变量

- 如果一个数据被广泛使用，最好的做法往往是先以函数的形式封装所有对该数据的访问
- 如果一个类达到需要自封装，考虑把这个类拆小

```js
let defaultOwnerDate = { firstName: 'martin', lastName: 'fowler' };
export function defaultOwner() { return defaultOwnerDate; }
export function setDefaultOwner(arg) { defaultOwnerDate = arg; }
```

### 引入参数对象

- 有一些数据总是结伴同行出没于一个个函数，让这组数据组成一个参数对象更好

### 提炼函数

- 阅读一段代码，理解其作用，以这段代码的用途为函数命名
- 如果你需要花时间浏览一段代码才能弄清楚它到底在干什么，就应该提炼到一个函数中
- 以函数“做什么”来命名，而不是它“怎么做”命名
- 只要提炼的过程中学到了东西，我的时间就没有白费
- 若提炼函数出现作用域变量，则以参数形式传递
- 局部变量过多就不适合使用提炼函数进行重构

### 提炼变量

- 表达式有可能非常复杂难以阅读，使用解释性变量能更好的管理
- 在类中提炼变量可以使用 getter 方法

### 提炼类

- 当一个类维护大量的函数和数据，往往不容易被理解
- 把一类功能成团的方法组成一个新的子类更好维护

### 改变函数声明

- 改进函数名字：先写一句注释描述这个函数的用途，再把这句注释变成函数的名字
- 函数参数尽量松耦合，不跟整个对象进行耦合

### 用管道代替循环

- 用 filter、map 集合管道代替循环，提升代码可读性

```js
// bad
const names = [];
for (const i of input) {
  if (i.job === 'programmer') {
    names.push(i.name);
  }
}

// good
const names = input
  .filter(i => i.job === 'programmer')
  .map(i => i.name);
```

### 移动语句

- 元素的声明点和使用点相互靠近，方便代码理解
- 将关联的代码集中到一块，方便做函数提炼

# 工程师编码要求

## 写代码要有洁癖

- 统一的代码规范
- 函数代码不要超过 IDE 屏幕
- 不要存在魔术数字
- 拒绝 else 关键字

## 架构设计，要精简

- 类的职责要单一，不要 manager
- 一个对象应该命令其他对象应该做什么，而不是查询它的状态来决定做什么
- 一行代码尽可能少的 . 运算符

## 实现功能，要易修改

- 屏蔽重复代码块
- 实现同一个功能的类，都放在一起

# 考察点

- 文件全小写中划线，私有属性用#前缀
- ajax、promise 要做异常处理
- if else 嵌套不能超过4层
- 不能存在重复代码
- 不能再函数内部修改外部变量
- 不能有超过3层的回调嵌套
- 多写关于为什么的注释
- 代码符合开闭原则，易于维护