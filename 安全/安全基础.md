# XSS

跨站脚本攻击(Cross-Site Scripting)。

## 原理

- 网站评论中插入一段 script 脚本
- 其他用户拉取评论的时候执行了这段脚本，`document.cookie` 发送到攻击者的服务器
- 盗取存储在客户端的 cookie 或者其他网站用于识别客户端身份的敏感信息，假冒合法用户与网站进行交互

## 类型

- 存储型 XSS
    - 主要出现在让用户输入数据供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击
- 反射型 XSS
    - 给用户发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。它的特点是非持久化，必须用户点击带有特定参数的链接才能引起

## 预防 XSS 攻击

- 使用 cookie 的 httpOnly 属性，加上了这个属性的 cookie 字段，JS 是无法进行读写的
- 过滤转义输入输出
- 避免使用 eval、 newFunction 等执行字符串的方法，除非确定字符串和用户输入无关
- 使用 innerHTML、document.write 的时候，如果数据是用户输入的，那么需要对象关键字符进行过滤与转义

### 前端

```js
// 过滤转义输入输出
function escapeHTML(target) {
  return target
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
}
```

### 服务端

```js
// 防止 xss 反射
ctx.set('X-Content-Type-Options', 'nosniff')
```

# CSRF

跨站请求伪造(Cross-site request forgery)。

## 原理

![01.jpg](https://qiniu.chenng.cn/2019-01-15-11-09-24.jpg)

要完成一次 CSRF 攻击，受害者必须依次完成两个步骤 ：

- 登录受信任网站 A，并在本地生成 Cookie
- 在不退出 A 的情况下，访问危险网站 B

CSRF 攻击主要是因为 Web 的隐式身份验证机制：Web 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。

## 目的

盗用你的登陆信息，以你的身份模拟发送各种请求。

- 当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中
- 这种攻击常常用于那些会改变用户的状态的请求，通常它们并不窃取数据，因为攻击者并不能看到响应的内容

## 预防 CRSF 攻击

- 检测 http referer 是否同域
    - referer 是可以伪造的，如配置 host。但是用户点击第三方网址，referer 是第三方网址，拒绝请求
- 添加校验 Token
    - 服务器生成随机数并附加在表单中，并要求客户端传回这个随机数
- 输入验证码
    - 因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作

# SQL 注入

SQL 注入攻击（SQL Injection），简称注入攻击。

## 原理

程序没有有效过滤用户的输入，使攻击者成功的向服务器提交恶意的 SQL 查询代码，导致原始的查询逻辑被改变。

## 预防 SQL 注入

- 严格限制 Web 应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害
- 对进入数据库的特殊字符进行转义处理，或编码转换
- 在应用发布之前建议使用专业的 SQL 注入检测工具进行检测，以及时修补被发现的 SQL 注入漏洞
- 避免网站打印出 SQL 错误信息，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入

# 对称/非对称加密

## 对称加密

![02.png](https://qiniu.chenng.cn/2018-11-06-22-30-43.png)

客户端与服务端都有一样的秘钥，进行加密解密。

## 非对称加密

![03.png](https://qiniu.chenng.cn/2018-11-06-22-31-08.png)

客户端与服务端都有一对公钥私钥：

- 客户端发送请求给服务端，拿服务端的公钥进行加密，请求到达服务端后服务端拿自己的私钥解密
- 服务端发送请求给客户端，拿客户端的公钥进行加密，请求达到客户端后客户端拿自己的私钥解密

### 数字证书

非对称加密需要防止中间人攻击，因为可能收到一个假的公钥，之后的通信看起来没什么问题，但其实信息已经泄露了。

这时候需要一个权威机构 CA 介入，权威部门颁发证书（Certificate），证书内容：

- 公钥（Public-key）
- 证书所有者（Subject）
- 证书发布机构（Issuer）
- 有效期（Validity）
- 签名算法（Signature Algorithm）

CA（Certificate Authority），CA 用自己的私钥给网站的公钥签名，相当于给网站背书。

在网络请求中，你不会直接得到请求网站的公钥，而是会得到一个【证书】，如果这个证书有发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密网站证书的签名，如果解密成功，证明网站的公钥没有问题。

# URL 跳转漏洞

- 三种跳转方式
    - META 标签内跳转
    - JavaScript 跳转
    - HTTP 头跳转
- 通过以 GET 或 POST 方式接受要跳转的 URL，然后以上面的方式进行跳转
- 用户的输入会进入上面 3 个地方，有可能出现 XSS
- 将域名设置为可信的 URL，一旦该 URL 包含一些跳转漏洞可能会导致安全限制被绕过：例如一些应用将 `youku.com` 设为可信 URL，如果 `youku.com` 内含一个 URL 跳转漏洞，最终引入的资源属于第三方恶意站点，可能会导致安全问题

# OAuth 2.0

## 概述

- OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据
- OAuth 的核心就是向第三方应用颁发令牌

三方的关系：

- 服务商：微博、github 等
- 用户：服务商的用户
- 第三方：第三方网址

参考：

- http://www.ruanyifeng.com/blog/2019/04/oauth_design.html
- http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html

## GitHub 认证流程

- A 网站让用户跳转到 GitHub
- GitHub 要求用户登录，然后询问"A 网站要求获得 xx 权限，你是否同意？"
- 用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码
- A 网站使用授权码，以及账户 id、secret 向 GitHub 请求令牌
- GitHub 返回令牌
- A 网站使用令牌，向 GitHub 请求用户数据

## 四种方法

- 授权码（authorization-code）
- 隐藏式（implicit）
- 密码式（password）：
- 客户端凭证（client credentials）

## GitHub 认证 Demo

https://github.com/ruanyf/node-oauth-demo

# Linux 主机入侵排查

- 通过已有的漏洞库规则对 HTTP 流量日志识别
- 检查第三方应用 MySQL 等是否存在弱口令
- 如果 grep、find 命令搜索漏洞后门

# Session 攻击与防护

## 攻击

- 猜测 Session
    - 使用安全的 Session 产生机制
- 盗取 Session
    - XSS
    - 网络 ARP 监听网络封包
    - 在网址使用 URL 传递 Session 时，通过 Referer 获取
- 固定 Session
    - URL 中携带固定的 Session，受害者登录后可以使用此 Session 操作

## 防护

- 禁止将 Session 使用 URL 传递
- 使用 HttpOnly
- 使用 Secure 强制 HTTPS 传输
- 用户登录之后立即更换 Session
- 通过特定资料识别身份：IP 地址、User-Agent等，更换之后需要重新授权
