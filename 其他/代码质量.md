<!--Eliminate-Low-Quality-Codes-->

重构：改善既有代码的设计

<!--more-->

# 命名

## 文件、文件夹

### 项目名

omi、element、master、project、test、vue、iview

### 目录名

build、static、config、src、examples、base、common、issues、assert

libs、models、plugins、skins、images、css、js

### 组件名

color-pick、button-groups、date-picker、option-grounp、jquery-select、jquery-swiper

index、message、menu、slider（滑块）、page、progress（进度条）、tooltip（提示）、tree、upload、time、button、checkbox、dialog、cascader（三级联动）

## HTML、CSS

- 外套 wrap
  - container
- 头部 header
  - head、header、nav、sub-nav、menu、sub-menu、branding
- 主要内容 main
  - bussiness-title 、bussiness-logo、bussiness-search、bussiness-search-results
- 左侧 main-left
  - side-bar、side-bar-a、side-bar-b
- 内容 content
   - radio-click、radio-heightlight、radio-active、input-seach-off、input-search-on
- 底部 footer
  - service、regsiter、partner、joinus、site-info
- CSS
  - 公共的 common.css
  - 动画 animation.css
  - 皮肤 skin.css
  - 文字 font.css
  - 主题 themes.css
  - 打印样式 print.css
  - 颜色 color.css

## JS

login、logout、expandList、getTotal、keySearch、submitForm、cancel、goMore、searchAll、searchCurrent、clearContent、uploadImage、searchResult

# 重构

## 重构基础

### 十六字心法

- 旧的不变
- 新的创建
- 一步切换
- 旧的再见

### 重构的概念

- 如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序
- 重构前，先检查自己是否有一套可靠的测试集，这些测试必须由自我检验能力
- 重构技术就是以微笑的步伐修改程序，如果犯下错误，很容易便可以发现它
- 好代码的检验标准就是人们是否能轻而易举的修改它

### 何时重构

- 添加新功能之前，重构让添加新功能更容易
- 使得代码更容易懂
- 肮脏的代码必须重构，但漂亮的代码也需要很多重构
- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值

### 代码的坏味道

- 神秘命名
  - 如果你想不出一个好名字，背后很可能潜藏着更深的设计问题
- 重复代码
  - 重复代码只是相似而不完全相同，首先尝试重组代码循序，把相似的部分放一起提炼
  - 重复代码位于同一个超类的不同子类中，使用函数上移避免两个字类相互调用
- 过长函数
  - 活得最长，最好的程序，函数都比较短

## 重构实践

### 以明确的函数代替参数

- 函数中的标记参数隐藏了函数调用中存在的差异性
- 移除标记参数不仅使代码更整洁，并且能够帮助开发工具更好地发挥作用

### 以查询取代临时变量

- 在类中使用 getter 查询某些计算值
- 不需要再将变量作为参数传递给提炼出来的小函数

### 内联函数

- 有时候语句块本来就清晰明了，就没有必要再提炼一个单独的函数

### 内联变量

- 如果变量不比表达式本身更具有表达力，应该使用内联的方式消除这个变量

### 函数分离

- 任何有返回值的函数，都不应该有看得到的副作用
- 如果遇到一个既有返回值又有副作用的函数，尝试将查询动作从修改动作中分离出来

### 函数组合成类

- 如果一组函数操作同一块数据（通常将这块数据作为参数传递），这时候考虑组建一个类

### 分解条件表达式

- 使用函数调用作为条件，更能清楚说明进入条件分支的原因

### 处理继承关系

- 公用函数上移到父类
- 公用字段上移到父类
- 构造函数内公用字段上移到父类，通过 super 赋值
- 特有函数下移到子类
- 特有字段下移到子类
- 以 new 不同的子类取代类型码

### 封装变量

- 如果一个数据被广泛使用，最好的做法往往是先以函数的形式封装所有对该数据的访问
- 如果一个类达到需要自封装，考虑把这个类拆小

```js
let defaultOwnerDate = { firstName: 'martin', lastName: 'fowler' };
export function defaultOwner() { return defaultOwnerDate; }
export function setDefaultOwner(arg) { defaultOwnerDate = arg; }
```

### 引入参数对象

- 有一些数据总是结伴同行出没于一个个函数，让这组数据组成一个参数对象更好

### 提炼函数

- 阅读一段代码，理解其作用，以这段代码的用途为函数命名
- 如果你需要花时间浏览一段代码才能弄清楚它到底在干什么，就应该提炼到一个函数中
- 以函数“做什么”来命名，而不是它“怎么做”命名
- 只要提炼的过程中学到了东西，我的时间就没有白费
- 若提炼函数出现作用域变量，则以参数形式传递
- 局部变量过多就不适合使用提炼函数进行重构

### 提炼变量

- 表达式有可能非常复杂难以阅读，使用解释性变量能更好的管理
- 在类中提炼变量可以使用 getter 方法

### 提炼类

- 当一个类维护大量的函数和数据，往往不容易被理解
- 把一类功能成团的方法组成一个新的子类更好维护

### 改变函数声明

- 改进函数名字：先写一句注释描述这个函数的用途，再把这句注释变成函数的名字
- 函数参数尽量松耦合，不跟整个对象进行耦合

### 用管道代替循环

- 用 filter、map 集合管道代替循环，提升代码可读性

```js
// bad
const names = [];
for (const i of input) {
  if (i.job === 'programmer') {
    names.push(i.name);
  }
}

// good
const names = input
  .filter(i => i.job === 'programmer')
  .map(i => i.name);
```

### 移动语句

- 元素的声明点和使用点相互靠近，方便代码理解
- 将关联的代码集中到一块，方便做函数提炼

# 代码考察

## 写代码要有洁癖

- 统一的代码规范
- 函数代码不要超过 IDE 屏幕
- 不要存在魔术数字
- 拒绝 else 关键字

## 架构设计，要精简

- 类的职责要单一，不要 manager
- 一个对象应该命令其他对象应该做什么，而不是查询它的状态来决定做什么
- 一行代码尽可能少的 . 运算符

## 实现功能，要易修改

- 屏蔽重复代码块
- 实现同一个功能的类，都放在一起

## 考察点

- 文件全小写中划线，私有属性用#前缀
- ajax、promise 要做异常处理
- if else 嵌套不能超过4层
- 不能存在重复代码
- 不能再函数内部修改外部变量
- 不能有超过3层的回调嵌套
- 多写关于为什么的注释
- 代码符合开闭原则，易于维护

## 好的例子

### Object.assign 设置默认对象

```js
const menuConfig = {
  title: 'Order',
  // User did not include 'body' key
  buttonText: 'Send',
  cancellable: true
};

function createMenu(config) {
  config = Object.assign({
    title: 'Foo',
    body: 'Bar',
    buttonText: 'Baz',
    cancellable: true
  }, config);

  // config now equals: {title: "Order", body: "Bar", buttonText: "Send", cancellable: true}
  // ...
}

createMenu(menuConfig);
```

### 使用解释变量

```js
const address = 'One Infinite Loop, Cupertino 95014';
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
const [, city, zipCode] = address.match(cityZipCodeRegex) || [];
saveCityZipCode(city, zipCode);
```

### 函数参数不使用 flag

```js
// Bad
function createFile(name, temp) {
  if (temp) {
    fs.create(`./temp/${name}`);
  } else {
    fs.create(name);
  }
}

// Good
function createFile(name) {
  fs.create(name);
}
function createTempFile(name) {
  createFile(`./temp/${name}`);
}
```

### 函数命名

函数名必须完美体现函数的功能，既不能多也不能少

```js
function getSongs(){
  return $.get('/songs').then((response){
    div.innerText = response.songs
  })
}
```

就违背了表里一致性，getSongs 表示获取歌曲，并没有暗示这个函数会更新页面，但是实际上函数更新了 div，这就是表里不一，正确的写法是

```js
// 要么纠正函数名
function getSongsAndUpdateDiv(){
  return $.get('/songs).then((response){
    div.innerText = response.songs
  })
}
```

```js
// 要么写成两个函数
function getSongs(){
  return $.get('/songs)
}
function updateDiv(songs){
  div.innerText = response.songs
}
getSongs().then((response)=>{
  updateDiv(response.songs)
})
```