<!--data-structure-and-algorithm-->

- [程序员的数学基础课](https://time.geekbang.org/column/article/76183)
- [数据结构与算法之美](https://time.geekbang.org/column/article/81835)
- [算法面试通关40讲](https://time.geekbang.org/course/intro/130)
- [大话数据结构](https://book.douban.com/subject/6424904/)

<!--more-->

# 数据结构

## 基本概念

- 数据结构就是一个容器，以某种特定的布局存储数据
- 这个布局使得数据结构在某些操作上非常高效，在另一些操作上则不那么高效
- 理解数据结构，这样就能为手头的问题选择最优的数据结构

![10.jpg](https://qiniu.chenng.cn/2018-12-15-11-07-01.jpg)

## 存储结构

### 顺序存储结构

- 把数据元素放在地址连续的存储单元里，数据间逻辑关系与物理关系一致
- 建立一个 9 个整形数据数组，计算机就在内存中开辟一段连续空间

### 链式存储结构

- 解决频繁变化的数据，使用顺序存储不方便
- 数据元素放在任意存储单元，这组存储单元可以是连续，也可以不连续，需要指针存放地址，通过地址就能找到关联数据的位置
- 《无间道》里面廖朝伟是警方在黑社会的卧底，一直与黄秋生进行单线联系，黄秋生遇害后廖朝伟就无法证明自己是一个警察，所以最后梁朝伟指着刘德华说：“对不起，我是警察”的是偶，刘德华马上说：“谁知道呢？”

## 数组

### 基本操作

- Insert - 在给定索引位置插入一个元素
- Get - 返回给定索引位置的元素
- Delete - 删除给定索引位置的元素
- Size - 获取数组内所有元素的总数

### 数组的误区

- 数组是适合查找操作，但是查找的时间复杂度并不为 O(1)，即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)
- 正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

### 下标从 0 开始

- 从数组存储的内存模型上来看，下标最确切的定义应该是偏移（offset）
- 如果用 a 来表示数组的首地址，`a[0]` 就是偏移为 0 的位置，也就是首地址，`a[k]` 就表示偏移 k 个 type_size 的位置：`a[k]_address = base_address + k * type_size`

## 栈

栈既可以用数组来实现，也可以用链表来实现

- 用数组实现的栈，叫作顺序栈
- 用链表实现的栈，叫作链式栈

`Array.push` 和 `Array.pop` 就是栈，可以在线上直接使用，时间复杂度是 O(1)

堆栈的基本操作

- Push - 在顶部插入元素
- Pop - 从堆栈中删除后返回顶部元素
- isEmpty - 如果堆栈为空，则返回 true
- Top - 返回顶部元素，但不从堆栈中删除

### Stack.js

```js
class Stack {

  constructor() {
    this.items = [];
  }

  push(item) {
    this.items.push(item);
  }

  pop() {
    return this.items.pop();
  }

  /**
   * 查看栈顶元素
   */
  peek() {
    return this.items[this.items.length - 1];
  }
}

module.exports = Stack;
```

### 应用

#### 两个栈实现四则运算

`3+5*8-6`

我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

```js
/**
 * 
 * @param {string} str 
 */
function arithmetic(str) {
  const ari_list = str.split('');
  const regDigital = /\d+/;
  const regOperation = /[\+\-\*\/]/;
  const digital = [];
  const operation = [];
  let result = 0;
  ari_list.forEach((item) => {
    if (regOperation.test(item)) {
      operation.push(item);
    }
    if (regDigital.test(item)) {
      digital.push(item);
    }
  });
}

arithmetic('3+5*8-6'); // 37
```

#### 浏览器的前进/后退

我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。

这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要【清空栈 Y】。

#### 十进制转二进制

```js
const Stack = require('./Stack');

function divideBy2(decNum) {
  const remStack = new Stack();
  let rem;
  let binaryStr = '';

  while (decNum > 0) {
    rem = Math.floor(decNum % 2);
    remStack.push(rem);
    decNum = Math.floor(decNum / 2);
  }

  while (!remStack.isEmpty()) {
    binaryStr += remStack.pop().toString();
  }

  return binaryStr;
}
```

## 队列

队列的基本操作：

- Enqueue() - 向队列末尾插入元素
- Dequeue() - 从队列头部移除元素
- isEmpty() - 如果队列为空，则返回 true
- Top() - 返回队列的第一个元素

### Queue.js

`Array.shift` 出队的时间复杂度是 O(n)，线上项目不可直接使用，因此需要实现一个 `Queue` 队列，以实现 O(1) 的时间复杂度

```js
class Queue {
  constructor(max) {
    this.data = new Array(max);
    this.q = 0;
    this.p = 0;
    this.size = 0;
    this.max = max;
  }
  
  enqueue(item) {
    if (this.size === this.max) {
      throw new Error('Queue overflow');
    }
    
    this.data[this.p++] = item;
    this.size++;
    if (this.p === this.max) {
      this.p = 0;
    }
  }
  
  dequeue() {
    if (this.size === 0) {
      throw new Error('Queue underflow');
    }
    
    const item = this.data[this.q++];
    this.size--;
    if (this.q === this.max) {
      this.q = 0;
    }
    
    return item;
  }
}
```

### 优先队列

优先级最高的元素优先出队，技术实现是入队时插入到对的位置

#### 测试用例

```js
const PriorityQueue = require('../__codes__/PriorityQueue');

describe('PriorityQueue', () => {
  it('enqueue', () => {
    const priorityQueue = new PriorityQueue();
    priorityQueue.enqueue('John', 2);
    priorityQueue.enqueue('Jack', 1);
    priorityQueue.enqueue('Camila', 3);
    expect(priorityQueue.print()).toBe('3-Camila->2-John->1-Jack');
  });
});
```

#### PriorityQueue.js

```js
class QueueElement {
  constructor(element, priority) {
    this.element = element;
    this.priority = priority;
  }
}

class PriorityQueue {
  constructor() {
    this.items = [];
  }

  enqueue(element, priority) {
    const queueElement = new QueueElement(element, priority);
    let added = false;
    for (let i = 0; i < this.items.length; i++) {
      if (queueElement.priority >= this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
        added = true;
        break;
      }
    }

    if (!added) {
      this.items.push(queueElement);
    }
  }

  dequeue() {
    return this.items.shift();
  }

  print() {
    return this.items.reduce((prev, curr) => {
      return prev === '' ?
        `${curr.priority}-${curr.element}` :
        `${prev}->${curr.priority}-${curr.element}`;
    }, '');
  }
}

module.exports = PriorityQueue;
```

## 链表

链表为了解决在数组中插入或者移除项成本过高的问题。

在链表中删除数据：

- 删除结点中“值等于某个给定值”的结点

    - 不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)

- 删除给定指针指向的结点

    - 我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 `p.next === q`，说明 p 是 q 的前驱结点。但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度

链表的基本操作：

- InsertAtEnd —— 在链表末尾插入指定元素
- InsertAtHead —— 在链表头部插入指定元素
- Delete —— 从链表中删除指定元素
- DeleteAtHead —— 删除链表的第一个元素
- Search —— 返回链表中的指定元素
- isEmpty —— 如果链表为空，返回 true

### 编码技巧

#### 指针丢失

插入节点的时候注意顺序，不要导致引用丢失

#### 边界条件

检查链表代码是否正确的边界条件有这样几个：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

#### 举例画图

![16.jpg](https://qiniu.chenng.cn/2018-12-19-22-40-31.jpg)

### 单链表

#### 测试用例

```js
const LinkedList = require('../__codes__/LinkedList');

describe('LinkedList', () => {
  it('append', () => {
    const list = new LinkedList();
    list.append(1);
    list.append(2);
    list.append(3);
    list.append(4);
    list.append(5);
    expect(list.toString()).toBe('1->2->3->4->5');
  });

  it('insert', () => {
    const list = new LinkedList();
    list.insert(0, 1);
    list.insert(1, 2);
    list.insert(2, 3);
    list.insert(1, 4);
    expect(list.toString()).toBe('1->4->2->3');
  });

  it('removeAt', () => {
    const list = new LinkedList();
    list.append(1);
    list.append(2);
    list.append(3);
    list.append(4);
    list.append(5);
    list.removeAt(3);
    expect(list.toString()).toBe('1->2->3->5');
  });

  it('remove', () => {
    const list = new LinkedList();
    list.append(1);
    list.append(2);
    list.append(3);
    list.append(4);
    list.append(5);
    list.remove(3);
    expect(list.toString()).toBe('1->2->4->5');
  });

  it('indexOf', () => {
    const list = new LinkedList();
    list.append(1);
    list.append(2);
    list.append(3);
    list.append(4);
    list.append(5);
    expect(list.indexOf(3)).toBe(2);
  });

  it('reverse', () => {
    const list = new LinkedList();
    list.append(1);
    list.append(2);
    list.append(3);
    list.append(4);
    list.append(5);
    list.reverse();
    expect(list.toString()).toBe('5->4->3->2->1');
  });
});
```

#### LinkedList.js

```js
class Node {
  constructor(element) {
    this.element = element;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.length = 0;
    this.head = null;
  }

  append(element) {
    const node = new Node(element);
    let curr;

    if (this.head === null) {
      this.head = node;
      this.length++;
      return;
    }

    curr = this.head;
    // 循环找到列表的最后一项
    while(curr.next) {
      curr = curr.next;
    }

    curr.next = node;
    this.length++;
  }

  insert(position, element) {
    if (position < 0 || position > this.length) {
      return false;
    }

    const node = new Node(element);
    let curr = this.head;
    let prev;
    let index = 0;

    if (position === 0) {
      node.next = curr;
      this.head = node;
      this.length++;
      return true;
    }

    while (index < position) {
      prev = curr;
      curr = curr.next;
      index++;
    }

    node.next = curr;
    prev.next = node;

    this.length++;
    return true;
  }

  removeAt(position) {
    if (position < 0 || position >= this.length) {
      return null;
    }

    let curr = this.head;
    let prev;
    let index = 0;

    if (position === 0) {
      this.head = curr.next;
      this.length--;
      return curr.element;
    }

    while(index < position) {
      prev = curr;
      curr = curr.next;
      index++;
    }

    // 将 prev 与 curr 的下一项连接在一起，跳过 curr，从而移除它
    prev.next = curr.next;
    this.length--;
    return curr.element;
  }

  remove(element) {
    let index = this.indexOf(element);
    return this.removeAt(index);
  }

  indexOf(element) {
    let curr = this.head;
    let index = 0;

    while(curr) {
      if (element === curr.element) {
        return index;
      }

      index++;
      curr = curr.next;
    }

    return -1;
  }

  isEmpty() {
    return this.length === 0;
  }

  size() {
    return this.length;
  }

  getHead() {
    return this.head;
  }

  toString() {
    let curr = this.head;
    let str = '';

    while(curr) {
      str += curr.element + (curr.next ? '->' : '');
      curr = curr.next;
    }

    return str;
  }

  reverse() {
    let curr = this.head;
    let prev = null;
    let next = null;
    while(curr) {
      next = curr.next;
      curr.next = prev;
      prev = curr;
      curr = next;
    }
    this.head = prev;
  }
}

module.exports = LinkedList;
```

### 双向链表


#### 测试用例

```js
const DoublyLinkedList = require('../__codes__/DoublyLinkedList');

describe('DoublyLinkedList', () => {
  it('insert', () => {
    const dbList = new DoublyLinkedList();
    dbList.insert(0, 1);
    dbList.insert(1, 2);
    dbList.insert(2, 3);
    dbList.insert(1, 4);
    expect(dbList.toString()).toBe('1->4->2->3');
  });

  it('moreveAt', () => {
    const dbList = new DoublyLinkedList();
    dbList.insert(0, 1);
    dbList.insert(1, 2);
    dbList.insert(2, 3);
    dbList.insert(3, 4);
    dbList.removeAt(2);
    expect(dbList.toString()).toBe('1->2->4');
  });
});
```

#### DoublyLinkedList.js

```js
class Node {
  constructor(element) {
    this.element = element;
    this.next = null;
    this.prev = null; // 比单链表多出来的属性
  }
}

class DoublyLinkedList {
  constructor() {
    this.length = 0;
    this.head = null;
    this.tail = null; // 比单链表多出来的属性
  }

  insert(position, element) {
    if (position < 0 || position > this.length) {
      return false;
    }

    const node = new Node(element);
    let curr = this.head;
    let prev;
    let index = 0;

    if (position === 0) { // 插入到第一个位置
      if (!this.head) { // 
        this.head = node;
        this.tail = node;
      } else {
        node.next = curr;
        curr.prev = node;
        this.head = node;
      }
    } else if (position === this.length) { // 插入到最后一个位置
      curr = this.tail;
      curr.next = node;
      node.prev = curr;
      this.tail = node;
    } else { // 插入到中间位置
      while(index < position) {
        prev = curr;
        curr = curr.next;
        index++;
      }

      node.next = curr;
      prev.next = node;

      curr.prev = node;
      node.prev = prev;
    }

    this.length++;
    return true;
  }

  removeAt(position) {
    if (position < 0 || position > this.length) {
      return null;
    }

    let curr = this.head;
    let prev;
    let index = 0;

    if (position === 0) { // 移除第一项
      this.head = curr.next;
      if (this.length === 1) {
        this.tail = null;
      } else {
        this.head.prev = null;
      }
    } else if (position === this.length - 1) { // 移除最后一项
      curr = this.tail;
      this.tail = curr.prev;
      this.tail.next = null;
    } else {
      while (index < position) {
        prev = curr;
        curr = curr.next;
        index++;
      }

      // 将 prev 和 curr 的下一项连在一起，跳过 curr
      prev.next = curr.next;
      curr.next.prev = prev;
    }

    this.length--;
    return curr.element;
  }

  toString() {
    let curr = this.head;
    let str = '';

    while(curr) {
      str += curr.element + (curr.next ? '->' : '');
      curr = curr.next;
    }

    return str;
  }
}

module.exports = DoublyLinkedList;
```

### 循环链表

循环链表与链表之间唯一的区别在于：最后一个元素指向下一个元素的指针(`this.tail.next`)不是 null、而是 `this.head`

## 跳表

- 跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)
- 链表加多级索引的结构，就是跳表，查询任意数据的时间复杂度就是 O(logn)
- 几级索引的结点总和就是 n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2。跳表的空间复杂度是 O(n)
- Redis 用跳表来实现有序集合，而不是红黑树，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树和跳表时间复杂度一致，按照区间来查找数据这个操作，红黑树的效率没有跳表高
- 插入一个元素最坏的时间复杂度是 O(n)

![17.png](https://qiniu.chenng.cn/2018-12-24-20-29-34.png)

## 散列表

- 散列表又称为哈希表
- 散列表表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来，如果没有数组，就没有散列表
- 散列表是动态集合结构中查找一个元素时间最短的

散列数据结构的性能取决于以下三个因素：

- 散列函数
- 散列表的大小
- 碰撞处理方法

### 散列函数

散列函数可以定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值

- 散列函数计算得到的散列值是一个非负整数, 因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数
- 如果 key1 = key2，那 hash(key1) == hash(key2)
- 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)

### 散列冲突

- 更好的散列函数
    - 一个表现良好的散列函数应该有较好的插入和查找性能且有较低的冲突可能性
- 线性探查
    - 线性探查法在向散列表中插入元素时，如果插入位置 position 已经被占据，就尝试插入 position+1 的位置，以此类推，直到找到空的位置
- 链表法
    - 在散列表中，每个桶（bucket）或者槽（slot）会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中
    - 当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)

### 数据结构

```js
class HashTable {
  constructor() {
    this.table = [];
  }

  djb2HashCode(key) {
    let hash = 5381; // 一个较大的素数基准值
    for (let i = 0; i < key.length; i++) {
        hash = hash * 33 + key.charCodeAt(i); // 基准值乘以 33 再加 ASCII 码值
    }
    return hash % 1013; // 除以1013取余
  }

  put(key, value) {
    const position = this.djb2HashCode(key);
    this.table[position] = value;
  }

  get(key) {
    return this.table[this.djb2HashCode(key)];
  }

  remove(key) {
    this.table[this.djb2HashCode(key)] = undefined;
  }
}
```

## 布隆过滤器

- 判断假永远是假，真不一定是真
- 原理是当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想
- 我们用布隆过滤器来记录已经爬取过的网页链接，假设需要判重的网页有 10 亿，那我们可以用一个 10 倍大小的位图来存储，也就是 100 亿个二进制位，换算成字节，那就是大约 1.2GB。之前我们用散列表判重，需要至少 100GB 的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多

---

[布隆过滤器实现](https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/bloom-filter/BloomFilter.js)

---

## 树

### 基本概念

- 节点：树中的每个元素都叫做节点
- 根节点：位于树顶顶部的节点，它没有父节点
- 内部节点：至少有一个子节点的节点
- 叶子节点：没有子元素的节点
- 高度：从 0 开始，根节点最高
- 深度：从 0 开始，根节点为 0
- 层数：从 1 开始，根节点为 1
- 满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点。
- 完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大

![18.png](https://qiniu.chenng.cn/2018-12-24-20-31-25.png)

满二叉树与完全二叉树图示：

![19.png](https://qiniu.chenng.cn/2018-12-24-20-36-34.png)

完全二叉树图示：

![20.png](https://qiniu.chenng.cn/2018-12-24-20-39-07.png)

完全二叉树可以使用数组来存储，节省内存：

- 无需像链表那样额外存储左右子节点的指针
- 完全二叉树要求最后一层的子节点都靠左
- 堆其实就是一种完全二叉树

数组的顺序存储法：

- 根节点 A 存储在下标 i = 1
- A 左子节点 2 * 1 = 2，A 右子节点 2 * 1 + 1 = 3
- B 左子节点 2 * 2 = 4，B 右子节点 2 * 2 + 1 = 5
- C 左子节点 2 * 3 = 6，C 右子节点 2 * 3 + 1 = 7

- 如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点
- 下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来

### 二叉树的遍历

![21.png](https://qiniu.chenng.cn/2018-12-24-20-55-58.png)

```js
// 前序遍历：根 => 左 => 右
function preOrder(node) {
  if (node == undefined) {
    return [];
  }
  return [node.data]
    .concat(preOrder(node.left))
    .concat(preOrder(node.right));
}

// 中序遍历：左 => 根 => 右
function inOrder(node) {
  if (node == undefined) {
    return [];
  }
  return inOrder(node.left)
    .concat(node.data)
    .concat(inOrder(node.right));
}

// 后序遍历：左 => 右 => 根
function postOrder(node) {
  if (node == undefined) {
    return [];
  }
  return postOrder(node.left)
    .concat(postOrder(node.right))
    .concat([node.data]);
}
```

### 二叉查找树

#### 概念

二叉查找树又称为有序二叉树、排序二叉树、二叉搜索树

- 左子树上所有节点的值均小于它的根节点的值
- 右子树上所有节点的值均大于它的根节点的值
- 左右子树也分别为二叉查找树

#### BinarySearchTree.js

```js
class Node {
  constructor(key) {
    this.key = key;
    this.left = null;
    this.right = null;
  }
}


class BinarySearchTree {
  constructor() {
    // 和 LinkedList 类似，不过这里是根元素，不是头节点
    this.root = null; 
    this.traverseList = [];
  }

  /**
   * 向树中插入一个新的键
   * @param {*} key 
   */
  insert(key) {
    const newNode = new Node(key);

    if (this.root === null) {
      this.root = newNode;
    } else {
      this._insertNode(this.root, newNode);
    }
  }

  _insertNode(node, newNode) {
    if (newNode.key < node.key) {
      if (node.left === null) {
        node.left = newNode;
      } else {
        this._insertNode(node.left, newNode);
      }
    } else {
      if (node.right === null) {
        node.right = newNode;
      } else {
        this._insertNode(node.right, newNode);
      }
    }
  }

  /**
   * 在树中查找一个键，如果存在返回 true、不存在返回 false
   * @param {*} key 
   */
  search(key) {
    return this._searchNode(this.root, key);
  }

  _searchNode(node, key) {
    if (node === null) {
      return false;
    }

    if (key < node.key) {
      return this._searchNode(node.left, key);
    }

    if (key > node.key) {
      return this._searchNode(node.right, key);
    }

    return true;
  }

  /**
   * 中序遍历所有节点
   */
  inOrderTraverse(cb) {
    this._cleanTraverseResult();
    this._inOrderTraverseNode(this.root, cb);
  }

  _inOrderTraverseNode(node, cb) {
    if (node === null) {
      return;
    }

    this._inOrderTraverseNode(node.left, cb);
    cb(node.key);
    this._inOrderTraverseNode(node.right, cb);
  }

  /**
   * 先序遍历所有节点
   */
  preOrderTraverse(cb) {
    this._cleanTraverseResult();
    this._preOrderTraverseNode(this.root, cb);
  }

  _preOrderTraverseNode(node, cb) {
    if (node === null) {
      return;
    }

    cb(node.key);
    this._preOrderTraverseNode(node.left, cb);
    this._preOrderTraverseNode(node.right, cb);
  }

  /**
   * 后序遍历所有节点
   */
  postOrderTraverse(cb) {
    this._cleanTraverseResult();
    this._postOrderTraverseNode(this.root, cb);
  }

  _postOrderTraverseNode(node, cb){
    if (node === null) {
      return;
    }

    this._postOrderTraverseNode(node.left, cb);
    this._postOrderTraverseNode(node.right, cb);
    cb(node.key);
  }

  /**
   * 返回树中最小值/键
   */
  min() {
    return this._minNode(this.root);
  }

  _minNode(node) {
    if (!node) {
      return null;
    }

    while (node && node.left !== null) {
      node = node.left;
    }

    return node.key;
  }

  /**
   * 返回树中最大值/键
   */
  max() {
    return this._maxNode(this.root);
  }

  _maxNode(node) {
    if (!node) {
      return null;
    }

    while (node && node.right) {
      node = node.right;
    }

    return node.key;
  }
  
  /**
   * 从树中移除某个键
   * @param {*} key 
   */
  remove(key) {
    const root = this._removeNode(key); // 返回值为了处理父节点的指针指向
  }

  _removeNode(node, key) {
    if (node === null) {
      return null;
    }

    if (key < node.key) {
      node.left = this._removeNode(node.left, key);
      return node; // 给父节点提供指针指向
    } else if (key > node.key) {
      node.right = this._removeNode(node.right, key);
      return node; // 给父节点提供指针指向
    } else {
      /**
       * 如果找到了 key === node.key，就要处理三种情况
       * 1. 叶子节点
       * 2. 只有左节点或者只有右节点的节点
       * 3. 有两个子节点的节点
      */

      // 1. 叶子节点
      if (node.left === null && node.right === null) {
        node = null; // 通过给节点赋值 null 来移除它
        return node; // node = null 是不够的，还需要处理指针，需要返回 null 来讲对应的父节点指针赋值 null
      }

      // 1. 只有左节点或者只有右节点的节点
      if (node.left === null) {
        node = node.right; // 只有右节点，对它的引用改为对它右子节点的引用，跳过它
        return node; // 让父节点指向该节点的右子节点
      } else if (node.right === null) {
        node = node.left;
        return node;
      }

      /**
       * 3. 有两个子节点的节点
       * - 找到需要移除的节点后，找到它右子树中最小的节点
       * - 用它右子树中最小节点的键去更新这个节点的键，这一步把它移除了
       * - 树中就存在两个相同键的节点了，需要把右子树中的最小节点移除，它在上一步已经被移到了要移除节点的位置了
       * - 向父节点返回更新后的节点引用
       */
      const aux = this._findMinNode(node.right);
      node.key = aux.key;
      node.right = this._removeNode(node.right, aux.key);
      return node;
    }
  }

  _findMinNode(node) {
    while (node && node.left !== null) {
      node = node.left;
    }
    return node;
  }

  getTraverseResult() {
    return this.traverseList.join('->');
  }

  _saveToTraverseResult(value) {
    this.traverseList.push(value);
  }

  _cleanTraverseResult() {
    this.traverseList = [];
  }
}

// module.exports = BinarySearchTree;

const bst = new BinarySearchTree();
bst.insert(11);
bst.insert(7);
bst.insert(15);
bst.insert(5);
bst.insert(3);
bst.insert(9);
bst.insert(8);
bst.insert(10);
bst.insert(13);
bst.insert(12);
bst.insert(14);
bst.insert(20);
bst.insert(18);
bst.insert(25);
bst.insert(6);

bst.inOrderTraverse(bst._saveToTraverseResult.bind(bst));
console.log(bst.getTraverseResult()); // 3->5->6->7->8->9->10->11->12->13->14->15->18->20->25

bst.preOrderTraverse(bst._saveToTraverseResult.bind(bst));
console.log(bst.getTraverseResult()); // 11->7->5->3->6->9->8->10->15->13->12->14->20->18->25

bst.postOrderTraverse(bst._saveToTraverseResult.bind(bst));
console.log(bst.getTraverseResult()); // 3->6->5->8->10->9->7->12->14->13->18->25->20->15->11

console.log(bst.min()); // 3

console.log(bst.max()); // 25

console.log(bst.search(8)); // true
```

#### 支持重复数据

在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。有两种方法支持重复数据：

- 二叉查找树中每一个节点不仅会存储一个数据，会通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上
- 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，把这个新插入的数据当作大于这个节点的值来处理。当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来

#### 时间复杂度

时间复杂度其实都跟树的高度成正比，也就是 O(height)

#### 相对于散列表的优点

- 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序；而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列
- 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)
- 尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高
- 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定

### 平衡二叉树

- 二叉树中任意一个节点的左右子树的高度相差不能大于 1
- 完全二叉树、满二叉树其实都是平衡二叉树
- 非完全二叉树也有可能是平衡二叉树

![26.png](https://qiniu.chenng.cn/2019-05-13-14-12-21.png)

不平衡的时候查找的复杂度就是 O(n) 了

### 红黑树

- 是平衡二叉查找树
- 红黑树中的节点，一类被标记为黑色，一类被标记为红色
- 根节点是黑色的
- 每个叶子节点都是黑色的空节点（NIL），叶子节点不存储数据；
- 任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点
- 在插入的时候解决红红冲突
- 在删除的时候解决黑黑冲突

### 堆

- 堆是一个完全二叉树，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
- 堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值
- 堆排序的时间复杂度是 O(n)

#### Max/Min Heap

```js
abstract class Heap {
  private heapContianer = [];
  protected pairIsInCorrectOrder(firstElement, secondElement) {
    return true;
  }

  private getLeftChildIndex(parentIndex) {
    return (2 * parentIndex) + 1;
  }

  private getRightChildIndex(parentIndex) {
    return (2 * parentIndex) + 2;
  }

  private rightChild(parentIndex) {
    return this.heapContianer[this.getRightChildIndex(parentIndex)];
  }

  private leftChild(parentIndex) {
    return this.heapContianer[this.getLeftChildIndex(parentIndex)];
  }

  private hasLeftChild(parentIndex) {
    return this.getLeftChildIndex(parentIndex) < this.heapContianer.length;
  }

  private hasRightChild(parentIndex) {
    return this.getRightChildIndex(parentIndex) < this.heapContianer.length;
  }

  private getParentIndex(childIndex) {
    return Math.floor((childIndex - 1) / 2);
  }

  private hasParent(childIndex) {
    return this.getParentIndex(childIndex) >= 0;
  }

  private parent(childIndex) {
    return this.heapContianer[this.getParentIndex(childIndex)];
  }

  private swap(indexOne, indexTwo) {
    const temp = this.heapContianer[indexTwo];
    this.heapContianer[indexTwo] = this.heapContianer[indexOne];
    this.heapContianer[indexOne] = temp;
  }

  public push(item) {
    this.heapContianer.push(item);
    this.heapifyUp();
    return this;
  }

  private heapifyUp() {
    // 取堆容器中的最后一个元素(数组中的最后一个或树中的左下方)
    // 并将其提升，直到其相对于其父元素的顺序正确
    let currIndex = this.heapContianer.length - 1;
    while (
      this.hasParent(currIndex) &&
      !this.pairIsInCorrectOrder(
        this.parent(currIndex),
        this.heapContianer[currIndex],
      )
    ) {
      const parentIndex = this.getParentIndex(currIndex);
      this.swap(currIndex, parentIndex);
      currIndex = parentIndex;
    }
  }

  public pop() {
    if (this.heapContianer.length === 0) {
      return null;
    }
    if (this.heapContianer.length === 1) {
      return this.heapContianer.pop();
    }

    // 把最后一个元素移到最前
    const item = this.heapContianer[0];
    this.heapContianer[0] = this.heapContianer.pop();
    this.heapifyDown();
    return item;
  }

  private heapifyDown() {
    // 将父元素与其子元素进行比较
    // 并使用适当的子元素交换父元素(MinHeap 的最小子元素，MaxHeap 的最大子元素)
    // 互换后，对下一个孩子也一样。
    let currIndex = 0;
    let nextIndex = null;

    while (this.hasLeftChild(currIndex)) {
      if (
        this.hasRightChild(currIndex) &&
        this.pairIsInCorrectOrder(
          this.rightChild(currIndex),
          this.leftChild(currIndex),
        )
      ) {
        nextIndex = this.getRightChildIndex(currIndex);
      } else {
        nextIndex = this.getLeftChildIndex(currIndex);
      }

      if (
        this.pairIsInCorrectOrder(
          this.heapContianer[currIndex],
          this.heapContianer[nextIndex],
        )
      ) {
        break;
      }

      this.swap(currIndex, nextIndex);
      currIndex = nextIndex;
    }
  }
}

class MaxHeap extends Heap {
  public pairIsInCorrectOrder(firstElement, secondElement) {
    return firstElement >= secondElement;
  }
}

class MinHeap extends Heap {
  public pairIsInCorrectOrder(firstElement, secondElement) {
    return firstElement <= secondElement;
  }
}
```

#### 优先级队列

堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素

#### 高性能定时器

假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。

我们就可以用优先级队列来解决。我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。这样，定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。

#### 利用堆求 Top K

- 每次询问前 K 大数据，我们都基于当前的数据重新排序的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小
- 可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比

### B+ 树

```sql
-- 根据某个值查找数据
select * from user where id=1234

-- 根据区间值来查找某些数据
select * from user where id > 1234 and id < 2345
```

需求分析：

- 散列表：查询性能很好，时间复杂度是 O(1)，散列表不能支持按照区间快速查找数据
- 平衡二叉查找树：查询的时间复杂度是 O(logn)。对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这不足以支持按照区间快速查找数据
- 跳表：是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。跳表也支持按照区间快速地查找数据，只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止

改造二叉查找树称为 B+ 树：

- 让二叉查找树支持按照区间来查找数据
- 树中的节点并不存储数据本身，而是只是作为索引
- 把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的

![25.jpeg](https://qiniu.chenng.cn/2019-01-20-20-33-10.jpeg)

使用 B+ 树：

- 我们只需要拿区间的起始值，在树中进行查找
- 当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止
- 所有遍历到的数据，就是符合区间值的所有数据

优化内存使用：

- 要为上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是占用的内存会非常多
- 将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找需要 IO 操作。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍
- 把索引构建成 m 叉树，减少树的高度，即可减少硬盘 IO，查找数据的效率也就提高了

## 图

图的类型：

- 无向图
- 有向图

在编程语言中，图可以表示为两种形式：

- 邻接矩阵
- 邻接列表

常见的图遍历算法：

- 广度优先搜索
- 深度优先搜索

## 用于索引的数据结构

- 散列表增删改查操作的性能非常好，时间复杂度是 O(1)。一些键值数据库，比如 Redis、Memcache，就是使用散列表来构建索引的。这类索引，一般都构建在内存中
- 红黑树作为一种常用的平衡二叉查找树，数据插入、删除、查找的时间复杂度是 O(logn)，也非常适合用来构建内存索引。Ext 文件系统中，对磁盘块的索引，用的就是红黑树
- B+ 树比起红黑树来说，更加适合构建存储在磁盘中的索引。B+ 树是一个多叉树，所以，对相同个数的数据构建索引，B+ 树的高度要低于红黑树。当借助索引查询数据的时候，读取 B+ 树索引，需要的磁盘 IO 次数非常更少。所以，大部分关系型数据库的索引，比如 MySQL、Oracle，都是用 B+ 树来实现的。
- 跳表也支持快速添加、删除、查找数据。而且，我们通过灵活调整索引结点个数和数据个数之间的比例，可以很好地平衡索引对内存的消耗及其查询效率。Redis 中的有序集合，就是用跳表来构建的。
- 布隆过滤器有一定的判错率。但是，我们可以规避它的短处，发挥它的长处。尽管对于判定存在的数据，有可能并不存在，但是对于判定不存在的数据，那肯定就不存在。而且，布隆过滤器还有一个更大的特点，那就是内存占用非常少。我们可以针对数据，构建一个布隆过滤器，并且存储在内存中。当要查询数据的时候，我们可以先通过布隆过滤器，判定是否存在。如果通过布隆过滤器判定数据不存在，那我们就没有必要读取磁盘中的索引了。对于数据不存在的情况，数据查询就更加快速了。
- 有序数组也可以被作为索引。如果数据是静态的，也就是不会有插入、删除、更新操作，那我们可以把数据的关键词（查询用的）抽取出来，组织成有序数组，然后利用二分查找算法来快速查找数据。

## 数据结构练习 - Leetcode

- 数组和链表
- 栈、队列和递归
- 排序和二分查找
- 散列表和字符串
- 二叉树和堆
- 贪心、分治、回溯和动态规划

### 数组和链表

- [Three Sum（求三数之和）](https://leetcode.com/problems/3sum/)
- [Majority Element（求众数）](https://leetcode.com/problems/majority-element/)
- [Missing Positive（求缺失的第一个正数）](https://leetcode.com/problems/first-missing-positive/)
- [Linked List Cycle I（环形链表）](https://leetcode.com/problems/linked-list-cycle/)
- [Merge k Sorted Lists（合并 k 个排序链表）](https://leetcode.com/problems/merge-k-sorted-lists/)

### 栈、队列和递归

- [Valid Parentheses（有效的括号）](https://leetcode.com/problems/valid-parentheses/)
- [Longest Valid Parentheses（最长有效的括号）](https://leetcode.com/problems/longest-valid-parentheses/)
- [Evaluate Reverse Polish Notatio（逆波兰表达式求值）](https://leetcode.com/problems/evaluate-reverse-polish-notation/)
- [Design Circular Deque（设计一个双端队列）](https://leetcode.com/problems/design-circular-deque/)
- [Sliding Window Maximum（滑动窗口最大值）](https://leetcode.com/problems/sliding-window-maximum/)
- [Climbing Stairs（爬楼梯）](https://leetcode.com/problems/climbing-stairs/)

### 排序和二分查找

- 实现归并排序、快速排序、插入排序、冒泡排序、选择排序
- 实现 O(n) 时间复杂度内找到一组数据的第 K 大元素
- [Sqrt(x) （x 的平方根）](https://leetcode.com/problems/sqrtx/)

### 散列表和字符串

- [实现一个 LRU 缓存淘汰算法](https://www.codewars.com/kata/53b406e67040e51e17000c0a)
- [Reverse String （反转字符串）](https://leetcode.com/problems/reverse-string/)
- [Reverse Words in a String（翻转字符串里的单词）](https://leetcode.com/problems/reverse-words-in-a-string/)
- [String to Integer (atoi)（字符串转换整数 (atoi)）](https://leetcode.com/problems/string-to-integer-atoi/)

### 二叉树和堆

- [Invert Binary Tree（翻转二叉树）](https://leetcode.com/problems/invert-binary-tree/)
- [Maximum Depth of Binary Tree（二叉树的最大深度）](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
- [Validate Binary Search Tree（验证二叉查找树）](https://leetcode.com/problems/validate-binary-search-tree/)
- [Path Sum（路径总和）](https://leetcode.com/problems/path-sum/)

### 贪心、分治、回溯和动态规划

- [Minimum Path Sum（最小路径和）](https://leetcode.com/problems/minimum-path-sum/)
- [Coin Change （零钱兑换）](https://leetcode.com/problems/coin-change/)
- [Best Time to Buy and Sell Stock（买卖股票的最佳时机）](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [Maximum Product Subarray（乘积最大子序列）](https://leetcode.com/problems/maximum-product-subarray/)
- [Triangle（三角形最小路径和）](https://leetcode.com/problems/triangle/)

## 数据结构练习 - Codewars

[![27.png](https://qiniu.chenng.cn/2019-05-13-16-40-09.png)](https://www.codewars.com/kata/latest/my-languages)

前期针对性训练，后期订阅，把每周二邮件发来的热门题目做一下

![28.png](https://qiniu.chenng.cn/2019-05-13-17-12-45.png)

# 算法

算法是解决特定问题求解步骤的描述

- 贪心算法: 局部最优解法
- 分治算法: 分成多个小模块，与原问题性质相同
- 动态规划: 每个状态都是过去历史的一个总结
- 回溯法: 发现原先选择不优时，退回重新选择
- 分支限界法

## 排序算法

### 原地性与稳定性

- 原地性，就是特指空间复杂度是 O(1) 的排序算法
- 稳定性：假设数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算

### 冒泡排序

- 在最优条件下时间复杂度为 O(n)
- 依次比较相邻的两个数，如果第一个比第二个小，不变(保证的稳定性)。
- 如果第一个比第二个大，调换顺序。一轮下来，最后一个是最大的数
- 对除了最后一个之外的数重复第一步，直到只剩一个数

![01.gif](https://qiniu.chenng.cn/2019-01-01-12-02-04.gif)

### 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。空间复杂度 1，不是稳定排序。

- 找出最小的数，和第一个交换位置
- 在剩下的数中，找出最二小的数，放在第二个
- 依次类推，排出顺序

![02.gif](https://qiniu.chenng.cn/2019-01-01-12-03-39.gif)

### 插入排序

空间复杂度 1，是稳定排序

- 把数组分为`已排序`和`未排序`两部分,第一个数为`已排序`，其余为`未排序`
- 从`未排序`抽出第一个数，和`已排序`部分比较，插入到合适的位置

![03.gif](https://qiniu.chenng.cn/2019-01-01-12-04-20.gif)

### 归并排序

归并排序使用了分治的思想，而这个过程需要使用递归来实现。

归并排序的时间复杂度任何情况下都是 O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是 O(n²)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。

- 不断将数组对半分，直到每个数组只有一个
- 将分出来的部分重新合并
- 合并的时候按顺序排列

![23.png](https://qiniu.chenng.cn/2019-01-05-12-21-05.png)

### 快速排序

- 从数组中选择中间一项作为主元
- 创建两个指针，左指针指向数组第一项，右指针指向数组最后一项
    - 移动左指针直到找到一个比主元大的元素
    - 移动右指针直到找到一个比主元小的元素
    - 交换这两个元素
    - 重复这个过程，直到左指针超过了右指针，这个过程使得所有比主元小的值都在主元左边，所有比主元大的值都在主元右边（划分）
- 对划分后的两个子数组重复上面两步

#### 快排与归并区别

归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

## 二分查找

二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。

### 普通版

容易出错的 3 个地方:

- 循环退出条件, 注意是 `low <= high`，而不是 `low < high`
- mid 的取值, mid = (low + high) / 2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出，改进的方法是将 mid 的计算方式写成 low+(high-low)/2
- low 和 high 的更新, low = mid + 1，high = mid - 1。注意这里的 +1 和 -1，如果直接写成 low = mid 或者 high=mid，就可能会发生死循环

```js
/**
 * @param {number[]} arr
 * @param {number} x
 */
function binarySearch(arr, x) {
  let left  = 0;
  let right = arr.length - 1;

  while(left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (x === arr[mid]) {
      return mid;
    }

    if (x < arr[mid]) {
      right = mid - 1;
      continue;
    }

    if (x > arr[mid]) {
      left = mid + 1;
      continue;
    }
  }
  
  return -1;
}

const arr = [1, 5, 10, 20, 30, 50, 100];
const x = 100;

console.log(binarySearch(arr, x)); // 6
```

### 递归版

```js
/**
 * @param {number[]} arr
 * @param {number} x
 */
function binarySearch(arr, x, left = 0, right = arr.length - 1) {
  const mid = Math.floor((left + right) / 2);
  if (x === arr[mid]) {
    return mid;
  }

  if (x > arr[mid]) {
    return binarySearch(arr, x, mid + 1, right);
  }

  if (x < arr[mid]) {
    return binarySearch(arr, x, left, mid - 1);
  }
  
  return -1;

}

const arr = [1, 5, 10, 20, 30, 50, 100];
const x = 100;

console.log(binarySearch(arr, x)); // 6
```

### 玻璃球问题

有一种玻璃小球，从一定高度丢下去撞到水泥地面上会撞碎。对于这种小球，摔碎的高度是一个固定值，高于这个值会摔碎，小于这个高度不会被摔碎。

对于一栋100层的建筑，和两个小球，怎么操作最快试出临界层数？

```js
function findCriticalPoint(heigh, remainNum, criticalPoint, currHeigh = 1, tryTimes = 1) {
  if (remainNum === 0) { return false; }

  if (remainNum === 2) {
    if (criticalPoint === currHeigh) {
      return tryTimes;
    }
    if (criticalPoint > currHeigh) {
      return findCriticalPoint(heigh, remainNum, criticalPoint, currHeigh + 10, tryTimes + 1);
    }

    if (criticalPoint < currHeigh) {
      return findCriticalPoint(heigh, remainNum - 1, criticalPoint, currHeigh - 10, tryTimes + 1);
    }
  }

  if (remainNum === 1) {
    if (criticalPoint === currHeigh) {
      return tryTimes;
    } 
    
    if (criticalPoint > currHeigh) {
      return findCriticalPoint(heigh, remainNum, criticalPoint, currHeigh + 1, tryTimes + 1);
    }
  }
}

console.log(findCriticalPoint(100, 2, 44));
```

优先尝试的楼层正确解为：

- 假设最后一次猜测为 k，则 Nk = N1 + (N1 - 1) + ... + 1，Nk 是等于或则大于 100 的第一个数
- 等差数列求和：N1 = 14， N2 = 27，N3 = 39

### 猜数字

系统和人玩一个猜数字的游戏，系统提供一个函数 gt(number) 告诉人 number 是否大于被猜测的数字。gt 函数可以被调用很多次。

数字在 1000-999999999 之间
人需要写一个函数 guess(gt) 去告诉系统最后猜测的结果。

比如，比如目标数字是 9999，可以不停调用 gt 来接近目标数字:

```js
gt(10) // false
gt(100) // false
gt(1000) // false
gt(10000) // true
gt(9999) // false ，找到最终结果
```

```js
const result = 999999999;

function gt(number) {
  return number > result;
}

function guess(gt, min = 999, max = 1000000000) {
  let mid = Math.floor((min + max) / 2);
  if (
    gt(mid + 1) === true &&
    gt(mid) === false
  ) {
    return mid;
  }

  if (gt(mid)) {
    return guess(gt, min, mid);
  } else {
    return guess(gt, mid, max);
  }
}

console.log(guess(gt));
```

## 斐波那契

```js
// 1, 1, 2, 3, 5, 8

// 递归版本
const cache = {1: 1, 2: 1};
const fibonacci = (n) => {
  return cache[n] || (cache[n] = fibonacci(n - 2) + fibonacci(n -1));
};

// 尾递归版本
const fibonaci = (n, a = 1, b = 1) => {
  if (n <= 1) { return b; }
  return fibonaci(n - 1, b, a + b);
}

// 递推版本
const fibonaci = (n) => {
  const F = [];
  F[0] = 0;
  F[1] = 1;
  for (let i = 2; i <= n; i++) {
    F[i] = F[i - 1] + F[i - 2];
  }

  return F[n];
}
```

## 0-1 背包问题

集群中有 5 个大索引文件，可以存到内存，A、B、C、D、E。因为内存有限（15T），所以需要决定哪个文件长期保存在内存中，哪些文件用到再重新计算。

| 文件名 | 大小  | 重算时间 |
| :----: | :---: | :------: |
|   A    |  2T   |  10min   |
|   B    |  3T   |   9min   |
|   C    |  5T   |  20min   |
|   D    |  10T  |  10min   |
|   E    |  1T   |   8min   |

### 穷举法

![08.png](https://qiniu.chenng.cn/2018-12-08-15-05-44.png)

```js
/**
 * 背包问题 枚举法
 *     大小 价值
 * A   2T  10 
 * B   3T  9
 * C   5T  20
 * D  10T  10
 * E   1T  8
 * @param {*} W 最大能承受的重量
 * @param {*} weight 物件的重量数组
 * @param {*} value 物件的价值数组
 * @param {number} [acc_w=0] 递归累计重量
 * @param {number} [d=0] 决策深度（递归深度）
 */
function knapsack(W, weight, value, acc_w = 0, d = 0) {
  if (d === weight.length || acc_w + weight[d] > W) {
    return 0;
  }

  return Math.max(
    knapsack(W, weight, value, acc_w + weight[d], d + 1, value[d]),
    knapsack(W, weight, value, acc_w, d + 1),
  );
}

const W = 20;
const weight = [2, 3, 5, 10, 1];
const value = [10, 9, 20, 10, 8];

console.log(knapsack(W, weight, value));
```

### 填表法

![09.png](https://qiniu.chenng.cn/2018-12-08-15-07-21.png)

## 动态规划

### 术语

- 最优子结构
- 边界
- 状态转移公式

### 爬楼梯问题(L70)

楼梯台阶有 12 阶，一步只能走 1 阶或者 2 阶，那么，请问走完楼梯有多少走法？

- 走到最后一个台阶的前一个情况，只能有两种，就是从第 11 台阶走一步上来，或者从 10 台阶走两步上来，X 种走法走到了 11 阶，Y 种走法走到了 10 阶，走到 12 阶的走法一定是 X + Y，这就是【最优子结构】
- 走到第一个台阶，1 种走法，没有台阶，那就 0 种走法，走到第二个台阶，2 种走法，其实这就是【边界】
- 【状态转移公式】：F(n) = F(n-1) + F(n-2)

```js
// 递归写法存在大量重复计算
const map = new Map();
function climbStairs(n) {
  if (n <= 2) {
    return n;
  }

  if (map.has(n)) { return map.get(n); }

  const stairs = climbStairs(n - 1) + climbStairs(n - 2);
  map.set(n, stairs);
  return stairs;
}
```

```js
// 动态规划版本
function climbStairs(n) {
  if (n <= 2) { return n; }

  let oneStepBefore = 2;
  let twoStepBefore = 1;
  let allWays = 0;

  for (let i = 2; i < n; i++) {
    allWays = oneStepBefore + twoStepBefore;
    twoStepBefore = oneStepBefore;
    oneStepBefore = allWays;
  }

  return allWays;
}
```

## 递归

### 特点

- 一个问题的解可以分解为几个子问题的解, 子问题就是数据规模更小的问题，求解思路完全一样
- 每次递归函数执行自己的时候，都需要把当前参数做某种修改，然后传入下一次递归
- 在递归函数的定义初始，应该有一个判断条件，当参数满足这个条件的时候，函数停止执行，并返回值

### 解题步骤

- 写出递推公式，找到终止条件
- 打印日志发现，递归值，结合条件断点进行调试
- 编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤

## hash 算法

哈希算法的应用非常非常多，最常见的七个，分别是

- 安全加密
- 唯一标识
- 数据校验
- 散列函数
- 负载均衡
- 数据分片
- 分布式存储

### 应用一：安全加密

像 MD5，有 2^128 个不同的哈希值，这个数据已经是一个天文数字了，所以散列冲突的概率要小于 1/2^128。

没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。比如 SHA-256 比 SHA-1 要更复杂、更安全，相应的计算时间就会比较长。

### 应用二：唯一标识

我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。

### 应用三：数据校验

我们知道，BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。

### 应用四：散列函数

散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。

散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。

### 应用五：负载均衡

我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。

### 应用六：数据分片

1. 如何统计“搜索关键词”出现的次数？

我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。

2. 如何快速判断图片是否在图库中？

我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。

假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（`2GB*0.75/152`）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器

## 朴素贝叶斯算法

在这 10 天中，有 4 天下雨，所以下雨的概率 P(B)=4/10。10 天中有 3 天，小明没有去上学，所以小明不去上学的概率 P(A)=3/10。在 4 个下雨天中，小明有 2 天没去上学，所以下雨天不去上学的概率 P(A|B)=2/4。

![24.jpeg](https://qiniu.chenng.cn/2019-01-15-09-38-17.jpeg)

## 五种算法模式

### 递归模式

```js
function recursion(level, param1, param2) {
  // 递归终止条件
  if (level > MAX_LEVEL) {
    // 打印结果
    return;
  }

  // 处理当前层级的逻辑
  processData(level, data);

  // 递归
  recursion(level + 1, p1, p2);

  // 如果需要，反向当前层级
  reverseState(level);
}
```

### DFS

```js
const visited = new Set();
function dfs(node) {
  visited.add(node);

  // 处理当前的 node

  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (!visited.has(child)) {
      dfs(child);
    }
  }
}
```

### BFS

```js
const visited = new Set();
function bfs(graph, start, end) {
  const queue = [];
  queue.push(start);

  while (queue.length) {
    node = queue.pop();
    visited.add(node);

    process(node);
    
    nodes = generateRelatedNodes(node);
    queue.push(nodes);
  }
}
```

### 二分查找

```js
function binarySearch(arr, x) {
  let left  = 0;
  let right = arr.length - 1;

  while(left <= right) {
    const mid = left + Math.floor((right - left) / 2) // 防溢出

    if (x === arr[mid]) {
      return mid;
    }

    if (x < arr[mid]) {
      right = mid - 1;
      continue;
    }

    if (x > arr[mid]) {
      left = mid + 1;
      continue;
    }
  }
  
  return -1;
}
```

### dp 方程

```js
// 状态定义，创建二维数组
const m = 10;
const n = 5;
const arr = new Array(m);
for (let i = 0; i < m; i++) {
  arr[i] = new Array(n);
  for (let j = 0; j < n; j++) {
    arr[i][j] = `[${i}, ${j}]`;
  }
}
const dp = arr;

// 初始状态
dp[0][0] = x;
dp[0][1] = y;

// DP 状态推导

for (let i = 0; i <= n; i++) {
  for (let j = 0; j <= matchMedia; j++) {
    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]);
  }
}

return dp[m][n]
```

## 切题四件套

- Clarification：询问题目细节、边界条件、极端错误情况
- Possible Solution：
    - 所有可能的解法
    - 时间和空间复杂度
    - 最优解
- Coding
- Test Cases

## 位运算

- `X & 1 === 0` 判断偶数（性能比 `X % 2 === 0` 要好）
- X = X & (X - 1) 清零最低位的 1
- X & -X 得到最低位的 1
- 向左位移：二进制数最后加 0 === 十进制数 * 2
- 逻辑右移：二进制去掉最后一位 === (十进制 / 2) 取整
- 算术右移：保留正负号

## LRU 淘汰算法

- 命中不调整
- 命中调整

# 复杂度

## 时间复杂度

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

### O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

### O(logn)

```js
// O(logn)
let i = 1;
while (i <= n)  {
 i = i * 2;
}

// O(nlogn)
// 归并排序、快速排序的时间复杂度都是 O(nlogn)
```

### O(n)

数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

### 数据结构复杂度

![06.png](https://qiniu.chenng.cn/2018-11-10-12-38-54.png)

### 排序算法复杂度

![07.png](https://qiniu.chenng.cn/2018-11-10-12-40-15.png)

## 空间复杂度

所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。
